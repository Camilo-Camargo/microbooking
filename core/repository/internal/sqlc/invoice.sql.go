// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: invoice.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createInvoice = `-- name: CreateInvoice :execresult
INSERT INTO invoice (from_wallet_id, to_wallet_id, status, amount, created_at)
VALUES (?, ?, ?, ?, ?)
`

type CreateInvoiceParams struct {
	FromWalletID int64         `json:"from_wallet_id"`
	ToWalletID   int64         `json:"to_wallet_id"`
	Status       InvoiceStatus `json:"status"`
	Amount       string        `json:"amount"`
	CreatedAt    time.Time     `json:"created_at"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createInvoice,
		arg.FromWalletID,
		arg.ToWalletID,
		arg.Status,
		arg.Amount,
		arg.CreatedAt,
	)
}

const deleteInvoice = `-- name: DeleteInvoice :exec
DELETE FROM invoice
WHERE invoice_id = ?
`

func (q *Queries) DeleteInvoice(ctx context.Context, invoiceID int64) error {
	_, err := q.db.ExecContext(ctx, deleteInvoice, invoiceID)
	return err
}

const getInvoice = `-- name: GetInvoice :one
SELECT invoice_id, from_wallet_id, to_wallet_id, status, amount, created_at, updated_at, deleted_at FROM invoice
WHERE invoice_id = ? LIMIT 1
`

func (q *Queries) GetInvoice(ctx context.Context, invoiceID int64) (Invoice, error) {
	row := q.db.QueryRowContext(ctx, getInvoice, invoiceID)
	var i Invoice
	err := row.Scan(
		&i.InvoiceID,
		&i.FromWalletID,
		&i.ToWalletID,
		&i.Status,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listInvoices = `-- name: ListInvoices :many
SELECT invoice_id, from_wallet_id, to_wallet_id, status, amount, created_at, updated_at, deleted_at FROM invoice
`

func (q *Queries) ListInvoices(ctx context.Context) ([]Invoice, error) {
	rows, err := q.db.QueryContext(ctx, listInvoices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.InvoiceID,
			&i.FromWalletID,
			&i.ToWalletID,
			&i.Status,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoiceById = `-- name: UpdateInvoiceById :exec
UPDATE invoice
SET from_wallet_id = ?, to_wallet_id = ?, status = ?, amount = ?, created_at = ?, updated_at = ?
WHERE invoice_id = ?
`

type UpdateInvoiceByIdParams struct {
	FromWalletID int64         `json:"from_wallet_id"`
	ToWalletID   int64         `json:"to_wallet_id"`
	Status       InvoiceStatus `json:"status"`
	Amount       string        `json:"amount"`
	CreatedAt    time.Time     `json:"created_at"`
	UpdatedAt    sql.NullTime  `json:"updated_at"`
	InvoiceID    int64         `json:"invoice_id"`
}

func (q *Queries) UpdateInvoiceById(ctx context.Context, arg UpdateInvoiceByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateInvoiceById,
		arg.FromWalletID,
		arg.ToWalletID,
		arg.Status,
		arg.Amount,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.InvoiceID,
	)
	return err
}
